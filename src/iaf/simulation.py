import numpy as np
from typing import Dict, Tuple, Optional
import time
from tqdm import tqdm
from pathlib import Path
import yaml
from ..utils import create_rng
from .iaf_neuron import IaF
from .source_population import SourcePopulation, create_source_population
from .synapse_group import SynapseGroup, create_synapse_group, SourcedSynapseGroup, DirectSynapseGroup
from .config import SimulationConfig


class Simulation:
    """
    A simulation of a neuron with synaptic inputs from a source population.

    This class handles the setup and running of a simulation with an integrate-and-fire
    neuron receiving inputs from a source population through synaptic connections.

    Attributes
    ----------
    source_populations : Dict[str, SourcePopulation]
        The source populations providing inputs to the neuron's synapse groups.
    neuron : IaF
        The integrate-and-fire neuron.
    synapses : Dict[str, SynapseGroup]
        The synapse groups providing inputs to the neuron.
    dt : float
        The time step of the simulation in seconds.
    """

    def __init__(
        self,
        source_populations: Dict[str, SourcePopulation],
        neuron: IaF,
        synapses: Dict[str, SynapseGroup],
        dt: float = 0.001,
        seed: Optional[int] = None,
    ):
        """
        Initialize the simulation.

        Parameters
        ----------
        source_populations : Dict[str, SourcePopulation]
            The source populations providing inputs to the neuron's synapse groups.
        neuron : IaF
            The neuron to simulate.
        synapses : Dict[str, SourcedSynapseGroup | DirectSynapseGroup]
            The synapse groups providing inputs to the neuron.
        dt : float
            The time step of the simulation in seconds (default: 0.001)
        seed : int, optional
            Random seed for reproducibility.
        """
        self.dt = dt
        self.rng = create_rng(seed)
        self.neuron = neuron
        self.source_populations: Dict[str, SourcePopulation] = {}

        for name, source_population in source_populations.items():
            self.add_source_population(source_population=source_population, name=name)

        for name, synapse_group in synapses.items():
            self.add_synapse_group(synapse_group=synapse_group, name=name)

        self._validate_dt_consistency()

    def _validate_dt_consistency(self):
        """Validate dt consistency across all components."""
        if self.dt != self.neuron.dt:
            raise ValueError(f"dt ({self.dt}) does not match neuron dt ({self.neuron.dt})")
        for name, synapse_group in self.neuron.synapse_groups.items():
            if self.dt != synapse_group.dt:
                raise ValueError(f"dt ({self.dt}) does not match synapse group dt ({name}:{synapse_group.dt})")
        for name, source_population in self.source_populations.items():
            if self.dt != source_population.dt:
                raise ValueError(f"dt ({self.dt}) does not match source population dt ({name}:{source_population.dt})")

    @classmethod
    def from_yaml(cls, fpath: Path):
        """Create a simulation from a YAML configuration file.

        Args:
            fpath: The path to the YAML configuration file.
        """
        with open(fpath, "r") as f:
            config = yaml.safe_load(f)
        return cls.from_config(SimulationConfig.model_validate(config))

    @classmethod
    def from_config(cls, config: SimulationConfig):
        """Create a simulation from a configuration object.

        Args:
            config: The configuration for the simulation.

        Returns:
            A new simulation instance.
        """
        # Create a new instance with base parameters
        source_populations = {
            name: create_source_population(source_config) for name, source_config in config.sources.items()
        }
        synapses = {name: create_synapse_group(synapse_config) for name, synapse_config in config.synapses.items()}
        sim = cls(
            source_populations=source_populations,
            neuron=IaF.from_config(config.neuron),
            synapses=synapses,
            dt=config.dt,
            seed=config.seed,
        )
        return sim

    def add_source_population(self, source_population: SourcePopulation, name: str | None = None):
        """Add a source population to the simulation.

        Args:
            source_population: The source population to add.
            name: The name of the source population.
        """
        if name is None:
            name = f"source_population_{len(self.source_populations)}"
        self.source_populations[name] = source_population

    def add_synapse_group(self, synapse_group: SynapseGroup, name: str | None = None):
        """Add a synapse group to the simulation.

        Args:
            synapse_group: The synapse group to add.
            name: The name of the synapse group (if None, will be generated by the neuron)
        """
        if synapse_group.source_population not in self.source_populations:
            raise ValueError(f"Source population {synapse_group.source_population} not found")
        self.neuron.add_synapse_group(synapse_group=synapse_group, name=name)

    def _prepare_weights(self, duration: int) -> dict:
        """Prepare the weights for the simulation."""
        # First figure out which synapse groups have plasticity activated
        plastic_synapse_groups = []
        for name in self.neuron.synapse_groups:
            if self.neuron.synapse_groups[name].plastic:
                plastic_synapse_groups.append(name)

        weights = {}
        for name in plastic_synapse_groups:
            if isinstance(self.neuron.synapse_groups[name], SourcedSynapseGroup):
                num_weights = self.neuron.synapse_groups[name].num_presynaptic_neurons
                weights[name] = np.zeros((duration, num_weights))
            elif isinstance(self.neuron.synapse_groups[name], DirectSynapseGroup):
                weights[name] = np.zeros((duration, self.neuron.synapse_groups[name].num_synapses))
            else:
                raise ValueError(f"Unknown synapse group type: {type(self.neuron.synapse_groups[name])}")

        return weights

    def _gather_weights(self, plastic_synapse_groups: list[str]) -> dict:
        """Gather the weights for the simulation."""
        weights = {}
        for name in plastic_synapse_groups:
            if isinstance(self.neuron.synapse_groups[name], SourcedSynapseGroup):
                synapse_weights = self.neuron.synapse_groups[name].weights
                idx_to_source = self.neuron.synapse_groups[name].presynaptic_source
                synapse_source = self.neuron.synapse_groups[name].source_population
                weights[name] = np.zeros(self.source_populations[synapse_source].num_inputs)
                for input_idx in range(self.source_populations[synapse_source].num_inputs):
                    weights[name][input_idx] = np.sum(synapse_weights[idx_to_source == input_idx])
            elif isinstance(self.neuron.synapse_groups[name], DirectSynapseGroup):
                weights[name] = self.neuron.synapse_groups[name].weights
            else:
                raise ValueError(f"Unknown synapse group type: {type(self.neuron.synapse_groups[name])}")
        return weights

    def run(self, duration: int, progress_bar: bool = True) -> dict:
        """
        Run the simulation.

        Parameters
        ----------
        duration : int
            The duration of the simulation in seconds.
        progress_bar : bool
            Whether to show a progress bar.

        Returns
        -------
        dict
            A dictionary containing the results of the simulation including the spike times,
            and the weights of each synapse group (at every second in the simulation).
        """
        steps_per_second = int(1 / self.dt)
        num_steps = int(duration * steps_per_second)

        spikes = np.zeros(num_steps, dtype=bool)
        weights = self._prepare_weights(duration=duration)

        # Initialize the neuron
        self.neuron.initialize()

        # Manage source populations
        sources_router = [synapse_group.source_population for synapse_group in self.neuron.synapse_groups.values()]
        sources_to_update = list(set(sources_router))
        source_needs_input = {source_name: True for source_name in sources_to_update}
        source_track_interval = {source_name: 0 for source_name in sources_to_update}
        source_rates = {source_name: None for source_name in sources_to_update}

        # Run the simulation
        seconds_progress = tqdm(range(duration)) if progress_bar else range(duration)

        for second in seconds_progress:
            for subsecond in range(steps_per_second):
                current_step = second * steps_per_second + subsecond

                # Update source populations
                for source_name in sources_to_update:
                    if source_needs_input[source_name]:
                        rates, interval = self.source_populations[source_name].generate_rates()
                        source_rates[source_name] = rates
                        source_track_interval[source_name] = interval - 1

                    else:
                        source_track_interval[source_name] -= 1

                    # Figure out if this source needs new input next time
                    source_needs_input[source_name] = source_track_interval[source_name] == 0

                rates = [source_rates[source_name] for source_name in sources_router]

                # Step the neuron with the given rates
                self.neuron.step(rates)

                # Record spike
                spikes[current_step] = self.neuron.spike

            current_weights = self._gather_weights(list(weights.keys()))
            for name in weights:
                weights[name][second] = current_weights[name]

        # Get spike times
        spike_times = np.where(spikes)[0]

        # Return results
        results = dict(
            spike_times=spike_times,
            weights=weights,
        )
        return results
